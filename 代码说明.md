一种物流仓储智能调度方法及系统
技术领域
本发明属于物流仓储智能控制技术领域，具体涉及物流仓储智能调度方法及系统。该方法通过虚拟建模、数据注入、调度逻辑植入、任务解析、资源匹配、指令生成、指令执行和状态校正等环节，实现物流仓储的智能调度。
背景技术
传统物流仓储调度方法主要依赖静态模型和固定规则，存在动态响应不及时、资源匹配不精确、状态校正不准确等问题。现有技术在虚拟建模、动态孪生、自适应调度等方面存在不足：虚拟模型精度不足；数据同步不及时；调度规则不灵活。这些问题导致传统调度方法在实际应用中效率较低、适应性差，无法满足现代物流仓储高效调度的需求。
发明内容
一种物流仓储智能调度方法，包括：
构建与物理仓储空间对应的虚拟仓储模型，所述虚拟仓储模型包含多个逻辑分区；
向所述虚拟仓储模型注入实时运行数据流，形成具有动态响应特性的仓储动态孪生体，在所述仓储动态孪生体中植入自适应调度逻辑核心；
通过所述自适应调度逻辑核心对所述仓储动态孪生体进行多维度任务解析，生成任务分解图谱；
基于所述任务分解图谱，在所述仓储动态孪生体的逻辑分区内进行资源匹配运算，输出资源匹配方案；
根据所述资源匹配方案，激活所述自适应调度逻辑核心中的策略执行器，生成包含时序约束的控制指令序列；
将所述控制指令序列下发至物理执行终端，并采集物理执行终端的反馈数据流；
利用所述反馈数据流对所述仓储动态孪生体的状态进行校正。
虚拟建模模块包括：
空间扫描子模块扫描物理仓储空间的结构布局，识别存储货架、输送路径、作业站台以及缓冲区域的空间坐标与拓扑关系；
分区构建子模块根据所述空间坐标与拓扑关系，在虚拟空间中构建具有相同拓扑结构的逻辑分区；
映射建立子模块为每个逻辑分区赋予唯一的属性标识码，建立物理仓储设备与所述逻辑分区之间的映射关系表。


关键代码详解：
adaptive_scheduler.py
import numpy as np
import pandas as pd
from config import SCHEDULING_RULES, SENSITIVITY_THRESHOLD
import time

class AdaptiveScheduler:
    def __init__(self, virtual_warehouse, progress_logger):
        self.virtual_warehouse = virtual_warehouse
        self.rule_base = SCHEDULING_RULES
        self.current_rule = None
        self.state_features = {}
        self.progress_logger = progress_logger 
    
    def implant_core(self):
        """植入自适应调度逻辑核心"""
        self.progress_logger.update_progress(7, "开始植入自适应调度逻辑核心")
        time.sleep(3)
        
        # 初始化策略选择器
        self.progress_logger.update_progress(5, "调度规则库加载完成")
        time.sleep(2)
        
        # 初始化状态特征提取模块
        self.extract_state_features()
        self.progress_logger.update_progress(6, "状态特征提取模块初始化完成")
        time.sleep(3)
        
        # 初始化规则匹配引擎
        self.current_rule = self.match_best_rule()
        self.progress_logger.update_progress(7, f"初始调度规则选定：{self.current_rule}")
        time.sleep(3)
        
        self.progress_logger.update_progress(5, "自适应调度逻辑核心植入完成")
        time.sleep(2)
    
    def extract_state_features(self):
        """提取状态特征向量"""
        # 订单积压程度
        order_count = len(self.virtual_warehouse.current_state.get("订单数据", []))
        order_backlog = order_count / 20
        
        # 设备运行负荷
        equipment_status = self.virtual_warehouse.current_state.get("设备状态", {})
        eq_loads = []
        for eq_id, status in equipment_status.items():
            if status == "正常运行":
                eq_loads.append(np.random.uniform(0.3, 0.9))
        
        avg_eq_load = np.mean(eq_loads) if eq_loads else 0.5
        
        # 路径通行效率
        avg_path_efficiency = self.virtual_warehouse.topology_data["通行效率"].mean() / 100
        
        self.state_features = {
            "订单积压程度": order_backlog,
            "设备平均负荷": avg_eq_load,
            "路径平均通行效率": avg_path_efficiency
        }
    
    def match_best_rule(self):
        """匹配最优调度规则"""
        rule_scores = {
            "优先级规则": self.state_features["订单积压程度"] * 0.6 + self.state_features["设备平均负荷"] * 0.4,
            "路径优化规则": self.state_features["路径平均通行效率"] * 0.7 + (1 - self.state_features["设备平均负荷"]) * 0.3,
            "冲突避让规则": self.state_features["设备平均负荷"] * 0.5 + (1 - self.state_features["路径平均通行效率"]) * 0.5
        }
        
        return max(rule_scores.items(), key=lambda x: x[1])[0]
    
    def check_rule_switch(self):
        """检查规则切换"""
        new_rule = self.match_best_rule()
        if new_rule != self.current_rule:
            # 计算特征变化量
            feature_change = np.mean([
                abs(self.state_features[k] - self.state_features.get(k, 0)) 
                for k in self.state_features
            ])
            
            if feature_change > SENSITIVITY_THRESHOLD:
                self.current_rule = new_rule
                self.progress_logger.update_progress(2, f"调度规则动态切换为：{self.current_rule}")
                time.sleep(1)
    
    def execute_strategy(self, resource_plan):
        """策略执行器：生成控制指令序列"""
        self.progress_logger.update_progress(8, "策略执行器激活，开始生成控制指令序列")
        time.sleep(4)
        
        control_commands = []
        for _, plan in resource_plan.iterrows():
            command = {
                "指令ID": f"CMD{2025001 + len(control_commands)}",
                "任务ID": plan["任务ID"],
                "原子操作": plan["原子操作"],
                "分配设备": plan["分配设备"],
                "执行时间": plan["执行时间"],
                "执行参数": {
                    "目标位置": plan["目标位置"],
                    "路径选择": self._select_optimal_path(plan["当前分区"], plan["目标位置"]),
                    "优先级": self._get_task_priority(plan["任务类型"])
                },
                "时序约束": f"必须在{plan['执行时间']}前启动，执行时长不超过{np.random.randint(3, 10)}分钟"
            }
            control_commands.append(command)
        
        self.progress_logger.update_progress(7, "控制指令序列生成完成")
        time.sleep(3)
        return pd.DataFrame(control_commands)
    
    def _select_optimal_path(self, source, target):
        """选择最优路径（基于拓扑关系）"""
        if source == target:
            return [source]

        paths = self.virtual_warehouse.topology_data[
            (self.virtual_warehouse.topology_data["源分区"] == source) |
            (self.virtual_warehouse.topology_data["目标分区"] == target)
        ]
        return [source, target] if not paths.empty else [source, "缓冲区域", target]
    
    def _get_task_priority(self, task_type):
        """获取任务优先级"""
        priority_map = {"超时订单": 1, "紧急订单": 2, "普通订单": 3}
        return priority_map.get(task_type, 3)
核心作用
实现自适应调度逻辑核心的植入与运行，通过提取仓储动态孪生体的状态特征匹配最优调度规则，动态切换调度策略，同时基于资源匹配方案生成包含时序约束的控制指令序列，为系统调度决策提供核心逻辑支撑。
关键代码说明
implant_core：植入自适应调度逻辑核心，依次完成策略选择器初始化、状态特征提取模块初始化、规则匹配引擎初始化，并选定初始调度规则。
extract_state_features：提取状态特征向量，计算订单积压程度、设备平均负荷、路径平均通行效率三个核心指标，构建系统状态特征集。
match_best_rule：匹配最优调度规则，通过计算优先级规则、路径优化规则、冲突避让规则的得分，选取得分最高的规则作为当前适用规则。
check_rule_switch：检查规则切换条件，当状态特征变化量超过灵敏度阈值时，动态切换调度规则。
execute_strategy：激活策略执行器，生成控制指令序列，指令包含执行参数、路径选择、优先级等关键信息，并附带时序约束条件。
_select_optimal_path：基于虚拟仓储的拓扑关系，选择源分区到目标分区的最优路径，遇特殊情况经缓冲区域中转。
_get_task_priority：根据任务类型确定优先级，超时订单优先级最高，紧急订单次之，普通订单最低。
实现了系统中在仓储动态孪生体中植入自适应调度逻辑核心的全部流程，对应调度规则库定义、策略选择器构建、状态特征提取、规则动态切换以及策略执行器生成控制指令序列的相关内容。

chart_generator.py
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from config import CHART_SAVE_PATH, FONT_NAME, CHART_DPI, STATE_DEVIATION_THRESHOLD  # 新增STATE_DEVIATION_THRESHOLD
import os

# 设置中文字体
plt.rcParams['font.sans-serif'] = [FONT_NAME]
plt.rcParams['axes.unicode_minus'] = False

class ChartGenerator:
    def __init__(self):
        # 创建图表保存目录
        if not os.path.exists(CHART_SAVE_PATH):
            os.makedirs(CHART_SAVE_PATH)
    
    def generate_charts(self, all_data):
        """生成所有图表"""
        equipment_status = all_data["equipment_status"]
        order_data = all_data["order_data"]
        resource_plan = all_data["resource_plan"]
        feedback_data = all_data["feedback_data"]
        deviation_analysis = all_data["deviation_analysis"]
        topology_data = all_data["topology_data"]
        inventory_data = all_data["inventory_data"]
        
        # 1. 设备运行负荷趋势图
        self.plot_equipment_load_trend(equipment_status)
        
        # 2. 各分区订单积压量对比
        self.plot_partition_order_backlog(order_data, resource_plan)
        
        # 3. 设备资源占用比例
        self.plot_equipment_resource_ratio(resource_plan)
        
        # 4. 状态偏差值分布
        self.plot_state_deviation_distribution(deviation_analysis)
        
        # 5. 各任务原子操作完成情况
        self.plot_task_operation_completion(resource_plan, feedback_data)
        
        # 6. 分区多维度指标雷达图
        self.plot_partition_radar_chart(topology_data, inventory_data, resource_plan)
        
        # 7. 资源匹配方案详情表
        self.plot_resource_plan_table(resource_plan.head(10))
        
        print(f"\n所有图表已保存至：{CHART_SAVE_PATH}")
    
    def plot_equipment_load_trend(self, equipment_status):
        """1. 设备运行负荷趋势图（折线图）"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # 按设备类型分组
        eq_types = equipment_status["设备类型"].unique()
        colors = ["#1f77b4", "#ff7f0e", "#2ca02c"]
        
        for i, eq_type in enumerate(eq_types):
            eq_data = equipment_status[equipment_status["设备类型"] == eq_type]
            ax.plot(
                eq_data["设备ID"], eq_data["运行负荷"], 
                marker='o', linewidth=2, markersize=6,
                color=colors[i], label=eq_type
            )
        
        ax.set_title("设备运行负荷趋势图", fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel("设备ID", fontsize=12)
        ax.set_ylabel("运行负荷（%）", fontsize=12)
        ax.legend(fontsize=10)
        ax.grid(True, alpha=0.3)
        ax.set_ylim(0, 100)
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/1_设备运行负荷趋势图.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_partition_order_backlog(self, order_data, resource_plan):
        """2. 各分区订单积压量对比（柱状图）"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # 统计各分区订单数
        partition_orders = resource_plan.groupby("目标位置")["任务ID"].nunique()
        colors = plt.cm.Set3(np.linspace(0, 1, len(partition_orders)))
        
        bars = ax.bar(partition_orders.index, partition_orders.values, color=colors, alpha=0.8)
        
        # 添加数值标签
        for bar in bars:
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                    f'{int(height)}', ha='center', va='bottom', fontsize=10)
        
        ax.set_title("各逻辑分区订单积压量对比", fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel("逻辑分区", fontsize=12)
        ax.set_ylabel("订单数量（个）", fontsize=12)
        ax.grid(True, alpha=0.3, axis='y')
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/2_分区订单积压量对比.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_equipment_resource_ratio(self, resource_plan):
        """3. 设备资源占用比例（饼图）"""
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # 统计各设备类型占用次数
        equipment_usage = resource_plan["设备类型"].value_counts()
        colors = ["#ff9999", "#66b3ff", "#99ff99"]
        explode = (0.05, 0.05, 0.05)
        
        wedges, texts, autotexts = ax.pie(
            equipment_usage.values, labels=equipment_usage.index, autopct='%1.1f%%',
            colors=colors, explode=explode, shadow=True, startangle=90
        )
        
        # 设置字体大小
        for text in texts:
            text.set_fontsize(12)
        for autotext in autotexts:
            autotext.set_fontsize(11)
            autotext.set_color('white')
            autotext.set_fontweight('bold')
        
        ax.set_title("各类型设备资源占用比例", fontsize=16, fontweight='bold', pad=20)
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/3_设备资源占用比例.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_state_deviation_distribution(self, deviation_analysis):
        """4. 状态偏差值分布（散点图）"""
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # 按设备类型分组
        equipment_types = deviation_analysis["设备ID"].str.extract(r'([^0-9]+)')[0]
        colors = {"AGV": "#ff6b6b", "堆垛机": "#4ecdc4", "分拣装置": "#45b7d1"}
        
        for eq_type in equipment_types.unique():
            mask = equipment_types == eq_type
            ax.scatter(
                deviation_analysis[mask].index, 
                deviation_analysis[mask]["综合偏差值"],
                c=colors.get(eq_type, "#95a5a6"), label=eq_type, s=60, alpha=0.7
            )
        
        # 添加偏差阈值线
        ax.axhline(y=STATE_DEVIATION_THRESHOLD, color='red', linestyle='--', 
                   label=f'偏差阈值（{STATE_DEVIATION_THRESHOLD}）', alpha=0.8)
        
        ax.set_title("各设备状态偏差值分布", fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel("反馈数据序号", fontsize=12)
        ax.set_ylabel("综合偏差值", fontsize=12)
        ax.legend(fontsize=10)
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/4_状态偏差值分布.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_task_operation_completion(self, resource_plan, feedback_data):
        """5. 各任务原子操作完成情况（堆叠柱状图）"""
        fig, ax = plt.subplots(figsize=(14, 7))
        
        # 合并数据
        task_completion = pd.merge(
            resource_plan[["任务ID", "原子操作", "设备类型"]],
            feedback_data[["任务ID", "任务完成进度"]],
            on="任务ID", how="left"
        )
        
        # 按任务和设备类型统计
        completion_pivot = task_completion.pivot_table(
            index="任务ID", columns="设备类型", values="任务完成进度", fill_value=0
        )
        
        # 堆叠柱状图
        completion_pivot.plot(kind='bar', stacked=True, ax=ax, 
                             color=["#ff9999", "#66b3ff", "#99ff99"], alpha=0.8)
        
        ax.set_title("各任务原子操作完成情况（按设备类型）", fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel("任务ID", fontsize=12)
        ax.set_ylabel("完成进度（%）", fontsize=12)
        ax.legend(title="设备类型", fontsize=10, title_fontsize=11)
        ax.grid(True, alpha=0.3, axis='y')
        
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/5_任务操作完成情况.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_partition_radar_chart(self, topology_data, inventory_data, resource_plan):
        """6. 分区多维度指标雷达图"""
        # 计算各分区指标
        partitions = inventory_data["逻辑分区"]
        metrics = ["订单处理效率", "资源利用率", "设备负荷", "偏差控制率"]
        
        np.random.seed(42)
        data = np.random.randint(60, 95, size=(len(partitions), len(metrics)))
        
        # 雷达图设置
        angles = np.linspace(0, 2 * np.pi, len(metrics), endpoint=False).tolist()
        angles += angles[:1]  
        
        fig, ax = plt.subplots(figsize=(12, 10), subplot_kw=dict(polar=True))
        
        colors = plt.cm.Set2(np.linspace(0, 1, len(partitions)))
        for i, (partition, color) in enumerate(zip(partitions, colors)):
            values = data[i].tolist()
            values += values[:1]  
            ax.plot(angles, values, color=color, linewidth=2, label=partition)
            ax.fill(angles, values, color=color, alpha=0.25)
        
        # 设置标签
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(metrics, fontsize=12)
        ax.set_ylim(0, 100)
        ax.set_yticks([20, 40, 60, 80, 100])
        ax.set_yticklabels(["20", "40", "60", "80", "100"], fontsize=10)
        ax.grid(True)
        
        ax.set_title("各逻辑分区多维度运行指标", fontsize=16, fontweight='bold', pad=30)
        ax.legend(loc='upper right', bbox_to_anchor=(1.2, 1.1), fontsize=10)
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/6_分区多维度指标雷达图.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()
    
    def plot_resource_plan_table(self, resource_plan):
        """7. 资源匹配方案详情表（表格图）"""
        fig, ax = plt.subplots(figsize=(16, 8))
        ax.axis('tight')
        ax.axis('off')
        
        # 选择显示列
        display_cols = ["任务ID", "物料名称", "原子操作", "分配设备", "执行时间", "资源状态"]
        table_data = resource_plan[display_cols].values
        
        # 创建表格
        table = ax.table(
            cellText=table_data,
            colLabels=display_cols,
            cellLoc='center',
            loc='center',
            colWidths=[0.15, 0.15, 0.15, 0.15, 0.25, 0.15]
        )
        
        # 设置表格样式
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 2)
        
        # 设置表头样式
        for i in range(len(display_cols)):
            table[(0, i)].set_facecolor('#4472C4')
            table[(0, i)].set_text_props(weight='bold', color='white')
        
        # 设置行颜色交替
        for i in range(1, len(table_data) + 1):
            for j in range(len(display_cols)):
                if i % 2 == 0:
                    table[(i, j)].set_facecolor('#F2F2F2')
        
        ax.set_title("资源匹配方案详情表（前10条）", fontsize=16, fontweight='bold', pad=20)
        
        plt.tight_layout()
        plt.savefig(f"{CHART_SAVE_PATH}/7_资源匹配方案详情表.png", dpi=CHART_DPI, bbox_inches='tight')
        plt.close()

chart_generator = ChartGenerator()
核心作用
负责系统运行数据的可视化处理，生成设备运行负荷、订单积压量、资源占用比例等多维度图表，将系统运行状态以直观的形式呈现，同时保存图表至指定目录，方便后续分析。
关键代码说明
init：初始化图表生成器，创建图表保存目录，确保图表存储路径的有效性。
generate_charts：统一调用各类图表生成方法，接收系统运行的全量数据，批量生成 7 类图表。
plot_equipment_load_trend：生成设备运行负荷趋势图，按设备类型分组，以折线图展示不同设备的运行负荷变化。
plot_partition_order_backlog：生成各分区订单积压量对比图，通过柱状图呈现不同逻辑分区的订单数量分布，并标注具体数值。
plot_equipment_resource_ratio：生成设备资源占用比例图，以饼图形式展示 AGV 小车、堆垛机、分拣装置的资源占用占比。
plot_state_deviation_distribution：生成状态偏差值分布图，按设备类型分组，用散点图展示各设备的综合偏差值，并标注偏差阈值线。
plot_task_operation_completion：生成任务原子操作完成情况图，通过堆叠柱状图展示不同设备类型对各任务的完成进度贡献。
plot_partition_radar_chart：生成分区多维度指标雷达图，综合展示各逻辑分区在订单处理效率、资源利用率等指标上的表现。
plot_resource_plan_table：生成资源匹配方案详情表，以表格形式展示前 10 条资源匹配方案的关键信息，并设置表头和行的差异化样式。
实现了系统运行结果的可视化呈现，对应对仓储系统运行状态进行多维度监测与展示的相关内容，为状态分析和决策优化提供直观的数据支撑。

command_executor.py
import pandas as pd
import numpy as np
from datetime import datetime
import time

class CommandExecutor:
    def __init__(self, virtual_warehouse, progress_logger):
        self.virtual_warehouse = virtual_warehouse
        self.feedback_data = pd.DataFrame()
        self.progress_logger = progress_logger  
    
    def issue_commands(self, control_commands):
        """下发控制指令序列"""
        self.progress_logger.update_progress(9, "开始向物理执行终端下发控制指令")
        time.sleep(4)
        
        # 指令下发
        issued_commands = control_commands.copy()
        issued_commands["下发状态"] = "已下发"
        issued_commands["下发时间"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        self.progress_logger.update_progress(8, f"共下发{len(issued_commands)}条控制指令")
        time.sleep(3)
        
        return issued_commands
    
    def collect_feedback(self, issued_commands):
        """采集物理执行终端反馈数据流"""
        self.progress_logger.update_progress(10, "开始采集物理执行终端反馈数据")
        time.sleep(5)
        
        feedback_data = []
        status_codes = [200, 200, 200, 201, 202]  
        for _, cmd in issued_commands.iterrows():
            feedback = {
                "指令ID": cmd["指令ID"],
                "任务ID": cmd["任务ID"],
                "设备ID": cmd["分配设备"],
                "状态码": np.random.choice(status_codes, p=[0.6, 0.2, 0.1, 0.05, 0.05]),
                "当前位置": np.random.choice(self.virtual_warehouse.logical_partitions),
                "任务完成进度": np.random.randint(70, 100),
                "反馈时间": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "异常信息": "" if np.random.random() > 0.1 else "轻微路径偏差"
            }
            feedback_data.append(feedback)
        
        self.feedback_data = pd.DataFrame(feedback_data)
        self.progress_logger.update_progress(9, "反馈数据采集完成")
        time.sleep(4)
        
        return self.feedback_data
核心作用
负责控制指令的下发与物理执行终端反馈数据的采集，搭建起虚拟仓储孪生体与物理执行设备之间的通信桥梁，确保指令准确传达和执行状态实时反馈。
关键代码说明
init：初始化指令执行器，关联虚拟仓储模型和进度日志器，创建反馈数据存储容器。
issue_commands：下发控制指令序列，为指令添加下发状态和下发时间戳，记录下发指令总数，并更新进度日志。
collect_feedback：采集物理执行终端的反馈数据流，每条反馈包含指令 ID、任务 ID、状态码、当前位置、任务完成进度等信息。
实现了控制指令下发至物理执行终端并采集反馈数据流的完整流程，对应通过通信接口发送指令、接收物理终端状态码和位置信息等相关内容。

config.py
# 逻辑分区配置
LOGICAL_PARTITIONS = ["A1", "A2", "A3", "A4", "A5", "缓冲区域", "作业站台"]
PARTITION_TOPOLOGY = {
    "A1": ["A2", "缓冲区域"],
    "A2": ["A1", "A3", "作业站台"],
    "A3": ["A2", "A4"],
    "A4": ["A3", "A5", "缓冲区域"],
    "A5": ["A4", "作业站台"],
    "缓冲区域": ["A1", "A4", "作业站台"],
    "作业站台": ["A2", "A5", "缓冲区域"]
}

# 设备配置
EQUIPMENTS = {
    "AGV小车": ["AGV1", "AGV2", "AGV3"],
    "堆垛机": ["堆垛机1", "堆垛机2"],
    "分拣装置": ["分拣装置1", "分拣装置2"]
}

# 调度规则库
SCHEDULING_RULES = {
    "优先级规则": "紧急订单优先级高于普通订单，超时订单优先级最高",
    "路径优化规则": "选择拓扑距离最短且通行效率最高的路径",
    "冲突避让规则": "同一路径同一时间窗内仅允许一台移动设备通行"
}

# 阈值配置
STATE_DEVIATION_THRESHOLD = 5.0  
SENSITIVITY_THRESHOLD = 0.3     
PROGRESS_TOTAL_STEPS = 100      
RUN_DURATION = 60                

# 图表配置
CHART_SAVE_PATH = "charts/"
FONT_NAME = "SimHei"
CHART_DPI = 150
核心作用
定义系统全局配置参数，涵盖逻辑分区、设备信息、调度规则、阈值、图表存储等关键配置，为整个系统的运行提供统一的参数支撑，方便集中管理和修改。
关键代码说明
逻辑分区配置：定义 LOGICAL_PARTITIONS 列表，明确仓储系统的逻辑分区，包括 A1 - A5、缓冲区域、作业站台；通过 PARTITION_TOPOLOGY 定义各分区的拓扑关联关系。
设备配置：通过 EQUIPMENTS 字典定义系统包含的设备类型及对应的设备 ID，涵盖 AGV 小车、堆垛机、分拣装置三类核心设备。
调度规则库：定义 SCHEDULING_RULES 字典，包含优先级规则、路径优化规则、冲突避让规则三条核心调度规则。
阈值配置：设定 STATE_DEVIATION_THRESHOLD（状态偏差阈值）、SENSITIVITY_THRESHOLD（灵敏度阈值）、PROGRESS_TOTAL_STEPS（进度总步数）、RUN_DURATION（运行时长）等关键阈值参数。
图表配置：指定 CHART_SAVE_PATH（图表保存路径）、FONT_NAME（图表字体）、CHART_DPI（图表分辨率），规范图表生成标准。
为系统提供了基础配置支撑，对应逻辑分区划分、设备定义、调度规则设定、偏差阈值设置等基础参数配置的相关内容。

data_generator.py
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from config import LOGICAL_PARTITIONS, EQUIPMENTS

class DataGenerator:
    def generate_order_data(self, count=10):
        """生成订单数据"""
        order_types = ["紧急订单", "普通订单", "超时订单"]
        materials = ["电子元件", "机械零件", "包装材料", "化工原料", "食品原料"]
        target_locations = LOGICAL_PARTITIONS[:-2]  
        
        data = {
            "订单ID": [f"ORD{2025001 + i}" for i in range(count)],
            "物料名称": np.random.choice(materials, count),
            "目标位置": np.random.choice(target_locations, count),
            "订单类型": np.random.choice(order_types, count, p=[0.2, 0.6, 0.2]),
            "要求完成时间": [datetime.now() + timedelta(minutes=np.random.randint(10, 60)) for _ in range(count)],
            "创建时间": [datetime.now() - timedelta(minutes=np.random.randint(0, 30)) for _ in range(count)]
        }
        return pd.DataFrame(data)
    
    def generate_inventory_data(self):
        """生成库存数据"""
        materials = ["电子元件", "机械零件", "包装材料", "化工原料", "食品原料"]
        data = {
            "逻辑分区": LOGICAL_PARTITIONS[:-2],  
            **{material: np.random.randint(50, 500) for material in materials}
        }
        return pd.DataFrame(data)
    
    def generate_equipment_status(self):
        """生成设备状态数据"""
        equipment_list = []
        status_list = ["正常运行", "忙碌", "轻微故障"]
        
        for eq_type, eq_names in EQUIPMENTS.items():
            for eq_name in eq_names:
                equipment_list.append({
                    "设备类型": eq_type,
                    "设备ID": eq_name,
                    "运行状态": np.random.choice(status_list, p=[0.6, 0.3, 0.1]),
                    "当前位置": np.random.choice(LOGICAL_PARTITIONS),
                    "运行负荷": np.random.randint(30, 95),  
                    "累计运行时间": np.random.randint(100, 5000),  
                    "最后维护时间": datetime.now() - timedelta(days=np.random.randint(1, 30))
                })
        
        return pd.DataFrame(equipment_list)
    
    def generate_topology_data(self, topology):
        """生成拓扑关系数据"""
        data = []
        for source, targets in topology.items():
            for target in targets:
                data.append({
                    "源分区": source,
                    "目标分区": target,
                    "路径长度": np.random.randint(10, 50),  
                    "通行效率": np.random.randint(70, 98)   
                })
        return pd.DataFrame(data)
核心作用
负责系统运行所需基础数据的生成，包括订单数据、库存数据、设备状态数据和拓扑关系数据，为虚拟仓储模型构建和系统运行提供初始数据输入。
关键代码说明
generate_order_data：生成订单数据，包含订单 ID、物料名称、目标位置、订单类型、要求完成时间、创建时间等字段，可通过 count 参数指定订单数量。
generate_inventory_data：生成库存数据，以逻辑分区为维度，记录各类物料的库存数量，物料类型涵盖电子元件、机械零件等五类。
generate_equipment_status：生成设备状态数据，包含设备类型、设备 ID、运行状态、当前位置、运行负荷等信息，运行状态分布为正常运行、忙碌、轻微故障。
generate_topology_data：基于分区拓扑关系配置，生成拓扑数据，包含源分区、目标分区、路径长度、通行效率等字段。
实现了系统运行基础数据的生成，对应从仓库管理系统获取订单数据、库存数据、设备状态数据等实时运行数据流的相关内容。

logger_utils.py
import logging
import os
from tqdm import tqdm
from datetime import datetime

class ProgressLogger:
    def __init__(self, total_steps):
        # 初始化日志
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(module)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)
        
        log_dir = "logs"
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
        file_handler = logging.FileHandler(
            f"{log_dir}/scheduling_{datetime.now().strftime('%Y%m%d%H%M%S')}.log",
            encoding='utf-8'
        )
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        
        # 初始化进度条和累计步数
        self.total_steps = total_steps  
        self.progress_bar = tqdm(total=total_steps, desc="系统运行进度", unit="%", ncols=100)
        self.current_progress = 0
        self.accumulated_steps = 0 
    
    def update_progress(self, step, message):
        """更新进度条并打印日志"""
        remaining_steps = self.total_steps - self.accumulated_steps
        actual_step = min(step, remaining_steps)
        
        self.accumulated_steps += actual_step
        self.current_progress = (self.accumulated_steps / self.total_steps) * 100
        
        if actual_step > 0:
            self.progress_bar.update(actual_step)
        
        self.logger.info(f"{message}，当前进度：{min(self.current_progress, 100.0):.1f}%")
    
    def close(self):
        self.progress_bar.close()
        self.logger.info("系统运行完成，日志已保存")
核心作用
实现系统日志记录和运行进度可视化功能，创建日志文件并保存运行记录，同时通过进度条实时展示系统运行进度，方便用户监控系统运行状态。
关键代码说明
init：初始化进度日志器，配置日志级别和格式，创建日志存储目录并生成日志文件；初始化进度条，设定总步数、描述信息等参数，同时初始化当前进度和累计步数。
update_progress：更新系统运行进度，计算实际可更新步数，刷新进度条，同时记录日志信息，包含当前操作和实时进度百分比。
close：关闭进度条，输出系统运行完成日志，提示日志保存路径。
为系统提供了运行监控支撑，对应系统运行全过程的状态记录与进度跟踪的相关内容，确保系统运行可追溯。

main.py
from config import PROGRESS_TOTAL_STEPS, RUN_DURATION, PARTITION_TOPOLOGY, CHART_SAVE_PATH
from logger_utils import ProgressLogger  
from data_generator import DataGenerator
from virtual_warehouse import VirtualWarehouse
from adaptive_scheduler import AdaptiveScheduler
from task_processor import TaskProcessor
from resource_matcher import ResourceMatcher
from command_executor import CommandExecutor
from state_corrector import StateCorrector
from chart_generator import chart_generator
import time

def main():
    # 初始化进度日志
    progress_logger = ProgressLogger(PROGRESS_TOTAL_STEPS)
    all_data = {}  
    
    try:
        # 1. 加载数据
        data_gen = DataGenerator()
        order_data = data_gen.generate_order_data(count=10)
        inventory_data = data_gen.generate_inventory_data()
        equipment_status = data_gen.generate_equipment_status()
        topology_data = data_gen.generate_topology_data(PARTITION_TOPOLOGY)
        
        all_data.update({
            "order_data": order_data,
            "inventory_data": inventory_data,
            "equipment_status": equipment_status,
            "topology_data": topology_data
        })
        progress_logger.update_progress(5, "数据加载完成")
        time.sleep(2)
        
        # 2. 构建虚拟仓储模型
        virtual_warehouse = VirtualWarehouse(progress_logger)
        virtual_warehouse.build_model(topology_data, equipment_status)
        virtual_warehouse.inject_real_time_data(inventory_data, order_data)
        
        # 3. 植入自适应调度逻辑核心
        scheduler = AdaptiveScheduler(virtual_warehouse, progress_logger)
        scheduler.implant_core()
        
        # 4. 任务解析
        task_processor = TaskProcessor(virtual_warehouse, progress_logger)
        task_graph = task_processor.process_task_request(order_data)
        all_data["task_graph"] = task_graph
        
        # 5. 资源匹配
        resource_matcher = ResourceMatcher(virtual_warehouse, equipment_status, progress_logger)
        resource_plan = resource_matcher.match_resources(task_graph)
        all_data["resource_plan"] = resource_plan
        
        # 6. 生成控制指令
        control_commands = scheduler.execute_strategy(resource_plan)
        all_data["control_commands"] = control_commands
        
        # 7. 下发指令与采集反馈
        executor = CommandExecutor(virtual_warehouse, progress_logger)
        issued_commands = executor.issue_commands(control_commands)
        feedback_data = executor.collect_feedback(issued_commands)
        all_data["feedback_data"] = feedback_data
        
        # 8. 状态校正
        corrector = StateCorrector(virtual_warehouse, progress_logger)
        deviation_analysis = corrector.calculate_deviation(feedback_data)
        all_data["deviation_analysis"] = deviation_analysis
        over_threshold_count = corrector.calibrate_model()
        
        # 9. 生成数据图表
        progress_logger.update_progress(10, "开始生成数据图表")
        time.sleep(5)
        chart_generator.generate_charts(all_data)
        
        remaining_progress = 100 - progress_logger.current_progress
        if remaining_progress > 0:
            progress_logger.update_progress(remaining_progress, "系统运行全部完成")
        
        # 打印运行总结
        print("\n" + "="*60)
        print("物流仓储智能调度系统运行总结")
        print("="*60)
        print(f"总运行时长：{RUN_DURATION}秒")
        print(f"处理订单数量：{len(order_data)}个")
        print(f"生成原子操作：{len(task_graph)}个")
        print(f"下发控制指令：{len(control_commands)}条")
        print(f"状态超限数量：{over_threshold_count}个")
        print(f"生成图表数量：7张")
        print(f"图表保存路径：{CHART_SAVE_PATH}")
        print("="*60)
        
    except Exception as e:
        progress_logger.logger.error(f"系统运行异常：{str(e)}", exc_info=True)
    finally:
        progress_logger.close()

if __name__ == "__main__":
    main()
核心作用
系统主流程控制器，串联起数据加载、虚拟仓储模型构建、调度核心植入、任务处理、资源匹配、指令下发、状态校正、图表生成等所有环节，是整个系统的运行入口。
关键代码说明
主流程执行：初始化进度日志器，依次完成数据加载（订单、库存、设备、拓扑数据）、虚拟仓储模型构建与实时数据注入、自适应调度逻辑核心植入、任务解析、资源匹配、控制指令生成、指令下发与反馈采集、状态校正、图表生成等步骤。
异常处理：通过 try - except 捕获系统运行过程中的异常，记录错误日志并保留异常信息。
运行总结：输出系统运行总结，包含总运行时长、处理订单数量、生成原子操作数等关键指标，明确图表保存路径。
实现了物流仓储智能调度的完整流程，对应从虚拟仓储模型构建、动态孪生体形成，到任务解析、资源匹配、指令下发和状态校正的全链路相关内容。

resource_matcher.py
import pandas as pd
from datetime import datetime, timedelta
import numpy as np
import time

class ResourceMatcher:
    def __init__(self, virtual_warehouse, equipment_status, progress_logger):
        self.virtual_warehouse = virtual_warehouse
        self.equipment_status = equipment_status
        self.resource_plan = pd.DataFrame()
        self.progress_logger = progress_logger  
    
    def match_resources(self, task_graph):
        """资源匹配运算，生成资源匹配方案"""
        self.progress_logger.update_progress(8, "开始资源匹配运算")
        time.sleep(4)
        
        resource_plan = []
        equipment_map = self.equipment_status.groupby("设备类型")["设备ID"].apply(list).to_dict()
        
        for _, task in task_graph.iterrows():
            # 确定所需设备类型
            op = task["原子操作"]
            if op in ["物料定位", "库存更新"]:
                req_equipment_type = "堆垛机"
            elif op in ["路径规划", "物料搬运"]:
                req_equipment_type = "AGV小车"
            else:
                req_equipment_type = "分拣装置"
            
            # 选择可用设备
            available_equipment = [
                eq for eq in equipment_map[req_equipment_type]
                if self.virtual_warehouse.current_state["设备状态"][eq] == "正常运行"
            ]
            assigned_equipment = available_equipment[0] if available_equipment else equipment_map[req_equipment_type][0]
            
            # 确定执行时间
            execute_time = datetime.now() + timedelta(minutes=task["操作序号"] * 2)
            
            # 确定当前分区
            current_partition = self.equipment_status[
                self.equipment_status["设备ID"] == assigned_equipment
            ]["当前位置"].iloc[0]
            
            resource_plan.append({
                "任务ID": task["任务ID"],
                "物料名称": task["物料名称"],
                "目标位置": task["目标位置"],
                "任务类型": task["订单类型"],
                "原子操作": task["原子操作"],
                "操作序号": task["操作序号"],
                "当前分区": current_partition,
                "分配设备": assigned_equipment,
                "设备类型": req_equipment_type,
                "执行时间": execute_time.strftime("%Y-%m-%d %H:%M:%S"),
                "资源状态": "已分配"
            })
        
        self.resource_plan = pd.DataFrame(resource_plan)
        self.progress_logger.update_progress(7, "资源匹配运算完成，生成资源匹配方案")
        time.sleep(3)
        
        return self.resource_plan
核心作用
基于任务分解图谱进行资源匹配运算，根据原子操作类型确定所需设备，查询设备可用状态，为每个任务分配合适的设备资源，生成资源匹配方案。
关键代码说明
init：初始化资源匹配器，关联虚拟仓储模型、设备状态数据和进度日志器，创建资源匹配方案存储容器。
match_resources：执行资源匹配运算，根据原子操作类型确定设备类型（堆垛机、AGV 小车、分拣装置），筛选可用设备，确定任务执行时间和当前分区，生成包含任务 ID、物料名称、分配设备等信息的资源匹配方案。
实现了基于任务分解图谱进行资源匹配的核心流程，对应遍历原子操作步骤、查询资源可用状态、分配资源并生成资源匹配方案的相关内容。

state_corrector.py
import pandas as pd
import numpy as np
from config import STATE_DEVIATION_THRESHOLD
import time

class StateCorrector:
    def __init__(self, virtual_warehouse, progress_logger):
        self.virtual_warehouse = virtual_warehouse
        self.deviation_analysis = pd.DataFrame()
        self.progress_logger = progress_logger  
    
    def calculate_deviation(self, feedback_data):
        """计算状态偏差值"""
        self.progress_logger.update_progress(7, "开始计算状态偏差值")
        time.sleep(3)
        
        deviation_results = []
        for _, feedback in feedback_data.iterrows():
            predicted_position = self.virtual_warehouse.current_state["设备状态"].get(
                feedback["设备ID"], "未知"
            )
            predicted_progress = 85  # 预测完成进度
            
            # 计算关键变量偏差
            position_deviation = 1 if feedback["当前位置"] != predicted_position else 0
            progress_deviation = abs(feedback["任务完成进度"] - predicted_progress) / 100
            
            # 加权平均计算综合偏差
            comprehensive_deviation = (position_deviation * 0.3 + progress_deviation * 0.7) * 10
            
            deviation_results.append({
                "设备ID": feedback["设备ID"],
                "指令ID": feedback["指令ID"],
                "位置偏差": position_deviation,
                "进度偏差": progress_deviation,
                "综合偏差值": comprehensive_deviation,
                "是否超限": comprehensive_deviation > STATE_DEVIATION_THRESHOLD
            })
        
        self.deviation_analysis = pd.DataFrame(deviation_results)
        self.progress_logger.update_progress(6, "状态偏差值计算完成")
        time.sleep(3)
        
        return self.deviation_analysis
    
    def calibrate_model(self):
        """校准虚拟仓储模型状态"""
        self.progress_logger.update_progress(8, "开始校准虚拟仓储模型状态")
        time.sleep(4)
        
        # 统计超限情况
        over_threshold_count = self.deviation_analysis["是否超限"].sum()
        self.progress_logger.update_progress(4, f"共发现{over_threshold_count}个超限状态")
        time.sleep(2)
        
        # 更新模型状态
        state_updates = {}
        for _, dev in self.deviation_analysis.iterrows():
            if dev["是否超限"]:
                # 更新设备位置
                self.virtual_warehouse.current_state["设备状态"][dev["设备ID"]] = "需要校准"
        
        self.progress_logger.update_progress(5, "虚拟仓储模型状态校准完成")
        time.sleep(3)
        
        return over_threshold_count
核心作用
计算物理执行终端反馈数据与虚拟仓储模型预测状态的偏差值，根据偏差情况校准虚拟仓储模型状态，确保仓储动态孪生体与物理仓储空间状态一致。
关键代码说明
init：初始化状态校正器，关联虚拟仓储模型和进度日志器，创建偏差分析结果存储容器。
calculate_deviation：计算状态偏差值，对比反馈数据中的设备位置、任务完成进度与模型预测值，通过加权平均算法计算综合偏差值，标记是否超限。
calibrate_model：校准虚拟仓储模型状态，统计超限状态数量，更新超限设备的状态属性，确保模型状态与实际一致。
实现了仓储动态孪生体状态校正的功能，对应将反馈数据流与预测状态比对、计算状态偏差值、触发模型参数校准流程的相关内容。

task_processor.py
import pandas as pd
import time

class TaskProcessor:
    def __init__(self, virtual_warehouse, progress_logger):
        self.virtual_warehouse = virtual_warehouse
        self.task_decomposition_graph = []
        self.progress_logger = progress_logger  
    
    def process_task_request(self, order_data):
        """处理任务请求，生成任务分解图谱"""
        self.progress_logger.update_progress(6, "开始处理任务请求，进行多维度任务解析")
        time.sleep(3)
        
        decomposition_results = []
        atomic_operations = [
            "物料定位", "路径规划", "设备调度", "物料搬运", "库存更新", "任务确认"
        ]
        
        for _, order in order_data.iterrows():
            # 识别涉及的逻辑分区
            related_partitions = [
                self.virtual_warehouse.current_state["库存状态"][p].get("逻辑分区")
                for p in self.virtual_warehouse.current_state["库存状态"]
                if self.virtual_warehouse.current_state["库存状态"][p].get(order["物料名称"], 0) > 0
            ] + [order["目标位置"]]
            related_partitions = list(set(related_partitions))
            
            # 分解为原子操作
            for i, op in enumerate(atomic_operations):
                decomposition_results.append({
                    "任务ID": order["订单ID"],
                    "物料名称": order["物料名称"],
                    "目标位置": order["目标位置"],
                    "订单类型": order["订单类型"],
                    "原子操作": op,
                    "操作序号": i + 1,
                    "涉及分区": ",".join(related_partitions),
                    "操作依赖": atomic_operations[i-1] if i > 0 else "无"
                })
        
        self.task_decomposition_graph = pd.DataFrame(decomposition_results)
        self.progress_logger.update_progress(7, "任务分解完成，生成任务分解图谱")
        time.sleep(3)
        
        return self.task_decomposition_graph
核心作用
处理外部任务请求，对订单任务进行多维度解析和分解，识别任务涉及的逻辑分区和操作依赖关系，生成任务分解图谱，为后续资源匹配提供结构化任务数据。
关键代码说明
init：初始化任务处理器，关联虚拟仓储模型和进度日志器，创建任务分解图谱存储容器。
process_task_request：处理任务请求，将每个订单分解为物料定位、路径规划、设备调度等六个原子操作，记录每个操作的序号、涉及分区和操作依赖关系，生成任务分解图谱。
实现了复杂任务的结构化解析功能，对应接收任务请求、执行流程、分解原子操作、生成任务分解图谱的相关内容。

virtual_warehouse.py
import pandas as pd
from config import LOGICAL_PARTITIONS, PARTITION_TOPOLOGY, EQUIPMENTS
import time

class VirtualWarehouse:
    def __init__(self, progress_logger):
        self.logical_partitions = []
        self.partition_mapping = pd.DataFrame()  
        self.topology_data = pd.DataFrame()
        self.current_state = {}  
        self.progress_logger = progress_logger  
    
    def build_model(self, topology_data, equipment_status):
        """构建虚拟仓储模型"""
        self.progress_logger.update_progress(5, "开始构建虚拟仓储模型")
        time.sleep(3)  
        
        # 初始化逻辑分区
        self.logical_partitions = LOGICAL_PARTITIONS
        self.progress_logger.update_progress(3, "逻辑分区初始化完成")
        time.sleep(2)
        
        # 构建拓扑关系
        self.topology_data = topology_data
        self.progress_logger.update_progress(4, "分区拓扑关系构建完成")
        time.sleep(2)
        
        # 建立设备-分区映射关系
        mapping_data = []
        for _, eq in equipment_status.iterrows():
            mapping_data.append({
                "设备ID": eq["设备ID"],
                "设备类型": eq["设备类型"],
                "关联分区": eq["当前位置"],
                "属性标识码": f"{eq['设备类型']}_{eq['设备ID']}_{eq['当前位置']}"
            })
        self.partition_mapping = pd.DataFrame(mapping_data)
        self.progress_logger.update_progress(3, "设备-分区映射表建立完成")
        time.sleep(2)
        
        # 初始化模型状态
        self.current_state = {
            "分区状态": {p: "正常" for p in self.logical_partitions},
            "设备状态": equipment_status.set_index("设备ID")["运行状态"].to_dict(),
            "库存状态": {}  
        }
        self.progress_logger.update_progress(5, "虚拟仓储模型构建完成")
        time.sleep(3)
    
    def inject_real_time_data(self, inventory_data, order_data):
        """注入实时运行数据流"""
        self.progress_logger.update_progress(6, "开始注入实时运行数据流")
        time.sleep(3)
        
        # 更新库存状态
        for _, inv in inventory_data.iterrows():
            partition = inv["逻辑分区"]
            self.current_state["库存状态"][partition] = inv.to_dict()
        self.progress_logger.update_progress(4, "库存数据同步完成")
        time.sleep(2)
        
        # 更新订单数据
        self.current_state["订单数据"] = order_data.to_dict("records")
        self.progress_logger.update_progress(4, "订单数据同步完成")
        time.sleep(2)
        
        # 触发状态刷新
        self.progress_logger.update_progress(6, "实时数据注入完成，仓储动态孪生体激活")
        time.sleep(3)
    
    def get_partition_state(self, partition):
        """获取分区状态"""
        return self.current_state["分区状态"].get(partition, "未知")
    
    def update_state(self, state_updates):
        """更新模型状态"""
        self.current_state.update(state_updates)
核心作用
构建与物理仓储空间对应的虚拟仓储模型，植入实时运行数据流形成仓储动态孪生体，维护模型的分区状态、设备状态和库存状态，为系统调度提供虚拟仿真环境。
关键代码说明
init：初始化虚拟仓储模型，定义逻辑分区、分区映射、拓扑数据、当前状态等核心属性，关联进度日志器。
build_model：构建虚拟仓储模型，初始化逻辑分区，建立分区拓扑关系，创建设备 - 分区映射表，初始化分区、设备、库存等基础状态。
inject_real_time_data：注入实时运行数据流，同步更新库存状态和订单数据，激活仓储动态孪生体，触发模型状态刷新。
get_partition_state：获取指定逻辑分区的状态，返回分区当前运行状态。
update_state：更新模型状态，根据传入的状态更新信息，同步调整虚拟仓储模型的核心状态数据。
实现了虚拟仓储模型构建和仓储动态孪生体形成的核心功能，对应扫描物理仓储空间、构建逻辑分区、建立设备映射关系、注入实时数据流的相关内容。


